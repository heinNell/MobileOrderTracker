SELECT pg_get_functiondef('public.sync_driver_location_and_broadcast'::regproc);

[
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.sync_driver_location_and_broadcast()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_driver_id uuid;\n  v_order_id uuid;\n  v_location jsonb;\n  v_lat numeric;\n  v_lng numeric;\nBEGIN\n  -- Only handle INSERT/UPDATE\n  IF TG_OP NOT IN ('INSERT','UPDATE') THEN\n    RETURN NEW;\n  END IF;\n\n  IF TG_TABLE_NAME = 'location_updates' THEN\n    v_driver_id := NEW.driver_id;\n    v_order_id := NEW.order_id;\n    v_location := COALESCE(NEW.location::jsonb, jsonb_build_object('latitude', NEW.latitude, 'longitude', NEW.longitude));\n    v_lat := COALESCE(NEW.latitude::numeric, (v_location->> 'latitude')::numeric);\n    v_lng := COALESCE(NEW.longitude::numeric, (v_location->> 'longitude')::numeric);\n  ELSIF TG_TABLE_NAME = 'orders' THEN\n    -- only act when assigned_driver_id, status, or last_driver_location changed on update\n    IF TG_OP = 'UPDATE' THEN\n      IF OLD.assigned_driver_id IS NOT DISTINCT FROM NEW.assigned_driver_id\n         AND OLD.status IS NOT DISTINCT FROM NEW.status\n         AND OLD.last_driver_location IS NOT DISTINCT FROM NEW.last_driver_location THEN\n        RETURN NEW;\n      END IF;\n    END IF;\n    v_driver_id := NEW.assigned_driver_id;\n    v_order_id := NEW.id;\n    v_location := COALESCE(NEW.last_driver_location, '{}'::jsonb);\n    IF v_location ? 'latitude' THEN\n      v_lat := (v_location ->> 'latitude')::numeric;\n      v_lng := (v_location ->> 'longitude')::numeric;\n    END IF;\n  ELSE\n    RETURN NEW;\n  END IF;\n\n  IF v_driver_id IS NOT NULL THEN\n    -- Upsert to driver_locations\n    INSERT INTO public.driver_locations (id, driver_id, order_id, location, latitude, longitude, accuracy_meters, speed_kmh, heading, timestamp, created_at)\n    VALUES (gen_random_uuid(), v_driver_id, v_order_id, v_location, v_lat, v_lng, COALESCE(NEW.accuracy_meters, NULL), COALESCE(NEW.speed_kmh, NULL), COALESCE(NEW.heading, NULL), COALESCE(NEW.timestamp, now()), now())\n    ON CONFLICT (driver_id) DO UPDATE\n    SET order_id = EXCLUDED.order_id,\n        location = EXCLUDED.location,\n        latitude = EXCLUDED.latitude,\n        longitude = EXCLUDED.longitude,\n        accuracy_meters = EXCLUDED.accuracy_meters,\n        speed_kmh = EXCLUDED.speed_kmh,\n        heading = EXCLUDED.heading,\n        timestamp = EXCLUDED.timestamp,\n        updated_at = now();\n\n    -- Insert into history\n    INSERT INTO public.driver_location_history (driver_id, order_id, location, latitude, longitude, accuracy_meters, speed_kmh, heading, timestamp, created_at)\n    VALUES (v_driver_id, v_order_id, v_location, v_lat, v_lng, COALESCE(NEW.accuracy_meters, NULL), COALESCE(NEW.speed_kmh, NULL), COALESCE(NEW.heading, NULL), COALESCE(NEW.timestamp, now()), now());\n\n    -- Broadcast\n    PERFORM realtime.broadcast_changes('driver:' || v_driver_id::text || ':locations', TG_OP, TG_OP, TG_TABLE_NAME, TG_TABLE_SCHEMA, NEW, OLD);\n    IF v_order_id IS NOT NULL THEN\n      PERFORM realtime.broadcast_changes('order:' || v_order_id::text || ':locations', TG_OP, TG_OP, TG_TABLE_NAME, TG_TABLE_SCHEMA, NEW, OLD);\n    END IF;\n\n    -- Also update orders.last_driver_location if this came from location_updates\n    IF TG_TABLE_NAME = 'location_updates' AND v_order_id IS NOT NULL THEN\n      UPDATE public.orders SET last_driver_location = v_location WHERE id = v_order_id;\n    END IF;\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  }
]